#!/bin/bash

# =============================================================================
# Script d'installation et configuration automatisée de Fail2Ban
# Version: 3.0 - Enterprise Edition
# Auteur: Dln
# Description: Installation et configuration sécurisée de Fail2Ban sur Debian
# =============================================================================

set -euo pipefail

# Configuration globale
readonly SCRIPT_NAME="$(basename "${0}")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
readonly LOG_FILE="/var/log/fail2ban-setup.log"
readonly BACKUP_DIR="/root/fail2ban-backup-$(date +%Y%m%d-%H%M%S)"
readonly TEMP_DIR="/tmp/fail2ban-setup-$$"
readonly REQUIRED_PACKAGES=("fail2ban" "ufw")
readonly SCRIPT_MARKER="# Generated by ${SCRIPT_NAME}"

# Couleurs pour l'affichage
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Variables globales
INTERACTIVE_MODE=true
SIMULATE_MODE=false
RESET_MODE=false
BANACTION="ufw"
SELECTED_SERVICES=()
DEFAULT_BANTIME="-1"
CLEANUP_NEEDED=false

# Liste des services avec configuration par défaut (port:logpath:filter:description)
declare -A SERVICES_CONFIG=(
    [ssh]="22:/var/log/auth.log:sshd:SSH login attempts"
    [apache]="80:/var/log/apache2/access.log:apache-access:Apache access failures"
    [apache-auth]="80:/var/log/apache2/error.log:apache-auth:Apache authentication failures"
    [nginx]="80:/var/log/nginx/access.log:nginx-http-auth:Nginx HTTP auth failures"
    [nginx-auth]="80:/var/log/nginx/error.log:nginx-http-auth:Nginx authentication failures"
    [postfix]="25:/var/log/mail.log:postfix:Postfix SMTP auth failures"
    [dovecot]="143:/var/log/mail.log:dovecot:Dovecot IMAP/POP3 failures"
    [vsftpd]="21:/var/log/vsftpd.log:vsftpd:VSFTPD login failures"
    [proftpd]="21:/var/log/proftpd/proftpd.log:proftpd:ProFTPD login failures"
    [webmin]="10000:/var/log/auth.log:webmin:Webmin login failures"
    [asterisk]="5060:/var/log/asterisk/security:asterisk:Asterisk SIP failures"
    [named-refused]="53:/var/log/syslog:named-refused:DNS query refusals"
    [exim]="25:/var/log/exim4/mainlog:exim:Exim SMTP failures"
    [ejabberd]="5222:/var/log/ejabberd/ejabberd.log:ejabberd:Ejabberd XMPP failures"
    [sshd-ddos]="22:/var/log/auth.log:sshd-ddos:SSH DDoS protection"
    [recidive]="22:/var/log/fail2ban.log:recidive:Repeat offenders"
    [wordpress]="80:/var/log/apache2/access.log:wordpress:WordPress login attempts"
    [mysql-auth]="3306:/var/log/mysql/error.log:mysql-auth:MySQL authentication failures"
)

# Configuration multi-logs pour certains services
declare -A SERVICES_MULTILOGS=(
    [nginx]="/var/log/nginx/access.log /var/log/nginx/error.log"
    [apache]="/var/log/apache2/access.log /var/log/apache2/error.log"
    [postfix]="/var/log/mail.log /var/log/postfix.log"
    [ssh]="/var/log/auth.log /var/log/secure"
)

# Filtres personnalisés avec échappement sécurisé
declare -A CUSTOM_FILTERS=(
    [wordpress]='[Definition]
# WordPress security filter
failregex = ^<HOST> -.*"(GET|POST).*/wp-login\.php.*HTTP/[0-9.]+" 4[0-9]{2}
            ^<HOST> -.*"(GET|POST).*/xmlrpc\.php.*HTTP/[0-9.]+" [45][0-9]{2}
            ^<HOST> -.*"(GET|POST).*wp-admin.*HTTP/[0-9.]+" 4[0-9]{2}
            ^<HOST> -.*"(GET|POST).*wp-content.*\.php.*HTTP/[0-9.]+" [45][0-9]{2}
ignoreregex = '

    [mysql-auth]='[Definition]
# MySQL authentication failure filter
failregex = ^.*Access denied for user.*from.*<HOST>
            ^.*Host.*<HOST>.*is blocked because of many connection errors
            ^.*User.*<HOST>.*was denied access on database
ignoreregex = '

    [webmin]='[Definition]
# Webmin login failure filter
failregex = ^<HOST> -.*POST /session_login\.cgi.*HTTP/[0-9.]+" 401
            ^.*Invalid login as .* from <HOST>
            ^.*Failed login from <HOST>
ignoreregex = '

    [ejabberd]='[Definition]
# Ejabberd XMPP authentication failure filter
failregex = ^.*Failed .* authentication for .* from <HOST>
            ^.*Authentication failed for .* from <HOST>
            ^.*Invalid user .* from <HOST>
ignoreregex = '
)

# =============================================================================
# GESTION DES SIGNAUX ET NETTOYAGE
# =============================================================================

# Fonction de nettoyage en cas d'erreur ou d'interruption
cleanup() {
    local exit_code=$?
    
    if [[ "$CLEANUP_NEEDED" == true ]]; then
        warning "Nettoyage en cours après interruption..."
        
        # Suppression du répertoire temporaire
        if [[ -d "$TEMP_DIR" ]]; then
            rm -rf "$TEMP_DIR"
            info "Répertoire temporaire supprimé : $TEMP_DIR"
        fi
        
        # Restauration depuis la sauvegarde si nécessaire
        if [[ -d "$BACKUP_DIR" ]] && [[ "$exit_code" -ne 0 ]]; then
            warning "Tentative de restauration de la configuration..."
            if restore_configuration; then
                info "Configuration restaurée avec succès"
            else
                error "Impossible de restaurer la configuration automatiquement"
                info "Sauvegarde disponible dans : $BACKUP_DIR"
            fi
        fi
        
        # Redémarrage de fail2ban si nécessaire
        if systemctl is-enabled fail2ban &>/dev/null; then
            systemctl restart fail2ban &>/dev/null || true
        fi
    fi
    
    log "INFO" "Script terminé avec le code de sortie : $exit_code"
    
    if [[ $exit_code -ne 0 ]]; then
        print_colored "${RED}" "\n[ERREUR] Le script s'est terminé de manière inattendue"
        print_colored "${YELLOW}" "Vérifiez les logs : $LOG_FILE"
        if [[ -d "$BACKUP_DIR" ]]; then
            print_colored "${YELLOW}" "Sauvegarde disponible : $BACKUP_DIR"
        fi
    fi
}

# Configuration du trap pour le nettoyage
trap cleanup EXIT INT TERM

# =============================================================================
# FONCTIONS UTILITAIRES ET LOGGING
# =============================================================================

# Fonction de logging améliorée
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local pid=$$
    
    echo -e "${timestamp} [${level}] [PID:${pid}] ${message}" | tee -a "${LOG_FILE}"
}

# Fonction d'affichage coloré
print_colored() {
    local color="$1"
    shift
    echo -e "${color}$*${NC}"
}

# Fonction d'erreur avec sortie
error_exit() {
    print_colored "${RED}" "[ERREUR] $*" >&2
    log "ERROR" "$*"
    exit 1
}

# Fonction d'erreur sans sortie
error() {
    print_colored "${RED}" "[ERREUR] $*" >&2
    log "ERROR" "$*"
}

# Fonction d'avertissement
warning() {
    print_colored "${YELLOW}" "[ATTENTION] $*"
    log "WARNING" "$*"
}

# Fonction d'information
info() {
    print_colored "${BLUE}" "[INFO] $*"
    log "INFO" "$*"
}

# Fonction de succès
success() {
    print_colored "${GREEN}" "[SUCCÈS] $*"
    log "SUCCESS" "$*"
}

# Fonction de debug
debug() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        print_colored "${CYAN}" "[DEBUG] $*"
        log "DEBUG" "$*"
    fi
}

# Fonction pour mode simulation
simulate() {
    print_colored "${CYAN}" "[SIMULATION] $*"
    log "SIMULATE" "$*"
}

# =============================================================================
# FONCTIONS DE SÉCURITÉ ET SANITISATION
# =============================================================================

# Sanitisation des chaînes pour injection dans fichiers de configuration
sanitize_string() {
    local input="$1"
    local max_length="${2:-100}"
    
    # Suppression des caractères dangereux et limitation de longueur
    echo "$input" | sed 's/[^a-zA-Z0-9._-]//g' | cut -c1-"$max_length"
}

# Sanitisation des ports
sanitize_port() {
    local port="$1"
    
    # Ne garder que les chiffres
    port=$(echo "$port" | sed 's/[^0-9]//g')
    
    # Vérifier la plage valide
    if [[ -n "$port" ]] && [[ "$port" -ge 1 ]] && [[ "$port" -le 65535 ]]; then
        echo "$port"
    else
        return 1
    fi
}

# Sanitisation des chemins de fichiers
sanitize_path() {
    local path="$1"
    
    # Résolution du chemin absolu et vérification
    if [[ "$path" =~ ^/[a-zA-Z0-9/_.-]+$ ]]; then
        realpath -m "$path" 2>/dev/null || echo "$path"
    else
        return 1
    fi
}

# Validation sécurisée des entrées utilisateur
validate_user_input() {
    local input="$1"
    local type="$2"
    
    case "$type" in
        "service_name")
            [[ "$input" =~ ^[a-zA-Z0-9_-]+$ ]] && [[ ${#input} -le 50 ]]
            ;;
        "port")
            [[ "$input" =~ ^[0-9]+$ ]] && [[ "$input" -ge 1 ]] && [[ "$input" -le 65535 ]]
            ;;
        "bantime")
            [[ "$input" == "-1" ]] || [[ "$input" =~ ^[0-9]+[smhdwy]?$ ]]
            ;;
        "logpath")
            [[ "$input" =~ ^/[a-zA-Z0-9/_.-]+$ ]] && [[ ${#input} -le 255 ]]
            ;;
        *)
            return 1
            ;;
    esac
}

# =============================================================================
# FONCTIONS D'AIDE ET INTERFACE
# =============================================================================

# Affichage de l'aide détaillée
show_help() {
    cat << EOF
${BOLD}Usage:${NC} ${SCRIPT_NAME} [OPTIONS]

${BOLD}Description:${NC}
    Script d'installation et configuration sécurisée de Fail2Ban pour Debian/Ubuntu.
    Supporte les modes interactif et automatisé avec fonctionnalités avancées.

${BOLD}Options principales:${NC}
    -h, --help              Affiche cette aide détaillée
    -n, --non-interactive   Mode non-interactif (automatisé)
    -s, --services SERVICES Liste des services (séparés par virgules)
    -b, --bantime TIME      Durée de bannissement par défaut
    
${BOLD}Options avancées:${NC}
    --simulate              Mode simulation (dry-run, aucune modification)
    --reset                 Supprime toutes les jails et filtres générés
    --backup-dir DIR        Répertoire de sauvegarde personnalisé
    --log-file FILE         Fichier de log personnalisé
    --debug                 Active le mode debug détaillé

${BOLD}Exemples d'utilisation:${NC}
    ${SCRIPT_NAME}                                    # Mode interactif complet
    ${SCRIPT_NAME} -n -s ssh,nginx -b 1h            # Mode automatique
    ${SCRIPT_NAME} --simulate -s ssh,apache         # Test sans modification
    ${SCRIPT_NAME} --reset                           # Suppression complète
    ${SCRIPT_NAME} --services ssh,nginx --bantime 1d # Configuration rapide

${BOLD}Services disponibles:${NC}
EOF
    printf "    %-15s %-8s %-30s %s\n" "SERVICE" "PORT" "FICHIER LOG" "DESCRIPTION"
    printf "    %s\n" "$(printf '=%.0s' {1..80})"
    
    for service in $(printf '%s\n' "${!SERVICES_CONFIG[@]}" | sort); do
        IFS=':' read -r port logpath filter description <<< "${SERVICES_CONFIG[$service]}"
        printf "    %-15s %-8s %-30s %s\n" "$service" "$port" "$logpath" "$description"
    done
    
    cat << EOF

${BOLD}Formats de temps supportés:${NC}
    -1, permanent   Bannissement permanent
    30s, 5m, 2h     Secondes, minutes, heures
    1d, 1w, 1y      Jours, semaines, années

${BOLD}Fichiers générés:${NC}
    /etc/fail2ban/jail.d/*.local     Configuration des jails
    /etc/fail2ban/filter.d/*.conf    Filtres personnalisés
    ${LOG_FILE}                      Journal du script

${BOLD}Support:${NC}
    Pour signaler un problème ou obtenir de l'aide :
    - Consultez les logs : ${LOG_FILE}
    - Vérifiez la configuration : fail2ban-client --test
    - Status des jails : fail2ban-client status
EOF
}

# =============================================================================
# FONCTIONS DE VALIDATION RENFORCÉES
# =============================================================================

# Vérification des privilèges root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error_exit "Ce script doit être exécuté en tant que root ou avec sudo"
    fi
    debug "Privilèges root confirmés (UID: $EUID)"
}

# Vérification de la distribution
check_distribution() {
    if [[ ! -f /etc/debian_version ]]; then
        error_exit "Ce script est conçu pour les distributions Debian/Ubuntu uniquement"
    fi
    
    local distro=$(grep PRETTY_NAME /etc/os-release | cut -d'"' -f2 2>/dev/null || echo "Inconnue")
    info "Distribution détectée : $distro"
    log "INFO" "Distribution: $distro, Version Debian: $(cat /etc/debian_version)"
}

# Vérification de l'espace disque
check_disk_space() {
    local required_space=100 # MB
    local available_space=$(df /etc | tail -1 | awk '{print $4}')
    local available_mb=$((available_space / 1024))
    
    if [[ $available_mb -lt $required_space ]]; then
        error_exit "Espace disque insuffisant. Requis: ${required_space}MB, Disponible: ${available_mb}MB"
    fi
    
    debug "Espace disque vérifié : ${available_mb}MB disponibles"
}

# Validation complète d'un port avec contexte
validate_port_advanced() {
    local port="$1"
    local service="${2:-unknown}"
    
    # Sanitisation
    if ! port=$(sanitize_port "$port"); then
        warning "Port invalide pour $service : '$1'"
        return 1
    fi
    
    # Vérification si le port est déjà utilisé
    if netstat -tuln 2>/dev/null | grep -q ":${port} "; then
        info "Port $port déjà en écoute (normal pour $service)"
    fi
    
    # Ports privilégiés
    if [[ $port -lt 1024 ]] && [[ $EUID -ne 0 ]]; then
        warning "Port privilégié $port nécessite les droits root"
    fi
    
    echo "$port"
    return 0
}

# Validation avancée du temps de bannissement
validate_bantime_advanced() {
    local bantime="$1"
    
    if [[ "$bantime" == "-1" ]] || [[ "$bantime" == "permanent" ]]; then
        echo "-1"
        return 0
    fi
    
    if [[ "$bantime" =~ ^[0-9]+$ ]]; then
        echo "$bantime"
        return 0
    fi
    
    if [[ "$bantime" =~ ^([0-9]+)([smhdwy])$ ]]; then
        local number="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        
        case "$unit" in
            s) echo "$number" ;;
            m) echo "$((number * 60))" ;;
            h) echo "$((number * 3600))" ;;
            d) echo "$((number * 86400))" ;;
            w) echo "$((number * 604800))" ;;
            y) echo "$((number * 31536000))" ;;
        esac
        return 0
    fi
    
    return 1
}

# Vérification approfondie des fichiers de log
check_logfile_advanced() {
    local logpath="$1"
    local service="$2"
    local create_if_missing="${3:-false}"
    
    # Vérification des logs multiples
    if [[ "$logpath" =~ [[:space:]] ]]; then
        info "Configuration multi-logs détectée pour $service"
        for single_log in $logpath; do
            if [[ ! -f "$single_log" ]]; then
                warning "Fichier de log manquant : $single_log"
                if [[ "$create_if_missing" == "true" ]]; then
                    touch "$single_log" && info "Fichier de log créé : $single_log"
                fi
            fi
        done
        return 0
    fi
    
    # Vérification simple
    if [[ ! -f "$logpath" ]]; then
        warning "Le fichier de log $logpath pour $service n'existe pas"
        
        if [[ "$INTERACTIVE_MODE" == "true" ]] && [[ "$SIMULATE_MODE" == "false" ]]; then
            read -rp "Créer le fichier de log ? [y/N] : " create_log
            if [[ "$create_log" =~ ^[Yy]$ ]]; then
                if touch "$logpath" 2>/dev/null; then
                    success "Fichier de log créé : $logpath"
                    return 0
                else
                    error "Impossible de créer le fichier de log : $logpath"
                    return 1
                fi
            fi
        fi
        
        if [[ "$SIMULATE_MODE" == "false" ]]; then
            read -rp "Continuer sans ce fichier de log ? [y/N] : " continue_anyway
            [[ "$continue_anyway" =~ ^[Yy]$ ]] || return 1
        fi
    else
        # Vérification des permissions de lecture
        if [[ ! -r "$logpath" ]]; then
            warning "Fichier de log non lisible : $logpath"
            return 1
        fi
        
        debug "Fichier de log validé : $logpath"
    fi
    
    return 0
}

# =============================================================================
# FONCTIONS D'INSTALLATION SÉCURISÉES
# =============================================================================

# Mise à jour et installation des paquets avec gestion d'erreur
install_packages() {
    info "Vérification et installation des paquets requis..."
    
    if [[ "$SIMULATE_MODE" == "true" ]]; then
        simulate "Installation des paquets : ${REQUIRED_PACKAGES[*]}"
        return 0
    fi
    
    # Test de connectivité réseau
    if ! ping -c 1 -W 5 8.8.8.8 &>/dev/null; then
        warning "Connectivité réseau limitée, mise à jour des paquets ignorée"
    else
        info "Mise à jour de la liste des paquets..."
        if ! apt update; then
            error_exit "Impossible de mettre à jour la liste des paquets"
        fi
    fi
    
    # Installation des paquets manquants
    local packages_to_install=()
    for package in "${REQUIRED_PACKAGES[@]}"; do
        if ! dpkg -l "$package" 2>/dev/null | grep -q "^ii"; then
            packages_to_install+=("$package")
        else
            info "$package est déjà installé"
        fi
    done
    
    if [[ ${#packages_to_install[@]} -gt 0 ]]; then
        info "Installation des paquets : ${packages_to_install[*]}"
        if ! DEBIAN_FRONTEND=noninteractive apt install -y "${packages_to_install[@]}"; then
            error_exit "Impossible d'installer les paquets requis"
        fi
        success "Paquets installés avec succès"
    fi
}

# Création sécurisée des répertoires
create_directories() {
    local dirs=("/etc/fail2ban/filter.d" "/etc/fail2ban/jail.d" "$BACKUP_DIR" "$TEMP_DIR")
    
    for dir in "${dirs[@]}"; do
        if [[ "$SIMULATE_MODE" == "true" ]]; then
            simulate "Création du répertoire : $dir"
            continue
        fi
        
        if [[ ! -d "$dir" ]]; then
            if mkdir -p "$dir"; then
                info "Répertoire créé : $dir"
                chmod 755 "$dir"
            else
                error_exit "Impossible de créer le répertoire : $dir"
            fi
        else
            debug "Répertoire existant : $dir"
        fi
    done
    
    CLEANUP_NEEDED=true
}

# Sauvegarde sécurisée de la configuration existante
backup_existing_config() {
    info "Sauvegarde de la configuration existante..."
    
    if [[ "$SIMULATE_MODE" == "true" ]]; then
        simulate "Sauvegarde dans : $BACKUP_DIR"
        return 0
    fi
    
    if [[ -d /etc/fail2ban ]]; then
        # Copie avec préservation des attributs
        if cp -rp /etc/fail2ban/* "$BACKUP_DIR/" 2>/dev/null; then
            success "Configuration sauvegardée dans $BACKUP_DIR"
            
            # Création d'un manifest de sauvegarde
            {
                echo "# Sauvegarde Fail2Ban - $(date)"
                echo "# Script: $SCRIPT_NAME"
                echo "# Utilisateur: $(whoami)"
                echo "# Hostname: $(hostname)"
                echo ""
                find "$BACKUP_DIR" -type f | sort
            } > "$BACKUP_DIR/backup_manifest.txt"
            
        else
            warning "Sauvegarde partielle ou échouée"
        fi
    else
        info "Aucune configuration existante à sauvegarder"
    fi
}

# Fonction de restauration de configuration
restore_configuration() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        error "Aucune sauvegarde disponible pour la restauration"
        return 1
    fi
    
    info "Restauration de la configuration depuis $BACKUP_DIR..."
    
    # Arrêt de fail2ban
    systemctl stop fail2ban 2>/dev/null || true
    
    # Suppression de la configuration actuelle
    rm -rf /etc/fail2ban/jail.d/*.local 2>/dev/null || true
    
    # Restauration
    if cp -rp "$BACKUP_DIR"/* /etc/fail2ban/ 2>/dev/null; then
        success "Configuration restaurée avec succès"
        systemctl start fail2ban 2>/dev/null || true
        return 0
    else
        error "Échec de la restauration"
        return 1
    fi
}

# =============================================================================
# FONCTIONS DE RÉINITIALISATION
# =============================================================================

# Fonction de reset complet
reset_fail2ban_config() {
    if [[ "$SIMULATE_MODE" == "true" ]]; then
        simulate "Suppression de toutes les jails et filtres personnalisés"
        simulate "Réinitialisation complète de Fail2Ban"
        return 0
    fi
    
    print_colored "${YELLOW}" "⚠️  ATTENTION : Réinitialisation complète de Fail2Ban ⚠️"
    print_colored "${RED}" "Cette opération va supprimer :"
    echo "  - Toutes les jails personnalisées (*.local)"
    echo "  - Tous les filtres personnalisés créés par ce script"
    echo "  - La configuration actuelle sera sauvegardée"
    
    if [[ "$INTERACTIVE_MODE" == "true" ]]; then
        read -rp "Êtes-vous sûr de vouloir continuer ? [y/N] : " confirm_reset
        if [[ ! "$confirm_reset" =~ ^[Yy]$ ]]; then
            info "Réinitialisation annulée"
            return 0
        fi
    fi
    
    # Sauvegarde avant reset
    backup_existing_config
    
    info "Arrêt du service Fail2Ban..."
    systemctl stop fail2ban || warning "Impossible d'arrêter Fail2Ban"
    
    # Suppression des jails personnalisées
    info "Suppression des jails personnalisées..."
    find /etc/fail2ban/jail.d -name "*.local" -type f -delete 2>/dev/null || true
    
    # Suppression des filtres créés par ce script
    info "Suppression des filtres personnalisés..."
    for filter in "${!CUSTOM_FILTERS[@]}"; do
        local filter_file="/etc/fail2ban/filter.d/${filter}.conf"
        if [[ -f "$filter_file" ]] && grep -q "$SCRIPT_MARKER" "$filter_file" 2>/dev/null; then
            rm -f "$filter_file"
            info "Filtre supprimé : $filter"
        fi
    done
    
    # Redémarrage avec la configuration par défaut
    info "Redémarrage de Fail2Ban avec la configuration par défaut..."
    if systemctl start fail2ban; then
        success "Réinitialisation terminée avec succès"
        info "Configuration sauvegardée dans : $BACKUP_DIR"
        
        # Affichage du statut
        sleep 2
        info "Statut après réinitialisation :"
        fail2ban-client status 2>/dev/null || warning "Impossible d'obtenir le statut"
    else
        error "Échec du redémarrage de Fail2Ban"
        return 1
    fi
}

# =============================================================================
# FONCTIONS DE CONFIGURATION AVANCÉES
# =============================================================================

# Affichage amélioré des services disponibles
show_available_services() {
    print_colored "${BOLD}${BLUE}" "\n📋 Services disponibles pour la protection Fail2Ban\n"
    
    printf "${BOLD}%-15s %-8s %-12s %-30s %s${NC}\n" "SERVICE" "PORT" "MULTI-LOG" "FICHIER LOG" "DESCRIPTION"
    printf "%s\n" "$(printf '=%.0s' {1..95})"
    
    for service in $(printf '%s\n' "${!SERVICES_CONFIG[@]}" | sort); do
        IFS=':' read -r port logpath filter description <<< "${SERVICES_CONFIG[$service]}"
        local multilog="Non"
        [[ -n "${SERVICES_MULTILOGS[$service]:-}" ]] && multilog="Oui"
        
        printf "%-15s %-8s %-12s %-30s %s\n" "$service" "$port" "$multilog" "$logpath" "$description"
    done
    echo
}

# Sélection interactive améliorée des services
select_services_interactive() {
    show_available_services
    
    print_colored "${CYAN}" "💡 Suggestions selon les services courants :"
    echo "  • Serveur web : ssh,nginx,wordpress"
    echo "  • Serveur mail : ssh,postfix,dovecot"
    echo "  • Serveur basique : ssh,sshd-ddos,recidive"
    echo
    
    local input_services
    while true; do
        read -rp "Entrez les services à configurer (séparés par virgules) : " input_services
        
        if [[ -z "$input_services" ]]; then
            warning "Aucun service spécifié"
            continue
        fi
        
        # Nettoyage et validation
        IFS=',' read -ra temp_services <<< "$input_services"
        SELECTED_SERVICES=()
        
        local valid_services=()
        local invalid_services=()
        
        for service in "${temp_services[@]}"; do
            service=$(echo "$service" | xargs | tr '[:upper:]' '[:lower:]') # Trim et lowercase
            if validate_user_input "$service" "service_name" && [[ -n "${SERVICES_CONFIG[$service]:-}" ]]; then
                SELECTED_SERVICES+=("$service")
                valid_services+=("$service")
            else
                invalid_services+=("$service")
            fi
        done
        
        if [